/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */

package com.lessmarkup.userinterface.model.global

import java.time.OffsetDateTime

import com.google.inject.Inject
import com.lessmarkup.TextIds
import com.lessmarkup.dataobjects.User
import com.lessmarkup.framework.helpers.{StringHelper, DependencyResolver}
import com.lessmarkup.interfaces.annotations._
import com.lessmarkup.interfaces.cache.EntityChangeType
import com.lessmarkup.interfaces.data.{ChangeTracker, DomainModel, DomainModelProvider, QueryBuilder}
import com.lessmarkup.interfaces.recordmodel._
import com.lessmarkup.interfaces.security.UserSecurity

class UserModelCollection @Inject() (domainModelProvider: DomainModelProvider, userSecurity: UserSecurity, changeTracker: ChangeTracker) extends EditableModelCollection[UserModel] {

  def readIds(query: QueryBuilder, ignoreOrder: Boolean): Seq[Long] = {
    query.from(classOf[User]).where("removed = $", false).toIdList
  }

  def getCollectionId: Int = {
    domainModelProvider.getCollectionId(classOf[User]).get
  }

  def read(queryBuilder: QueryBuilder, ids: Seq[Long]): Seq[UserModel] = {
    for (user <- queryBuilder.from(classOf[User]).where("removed = $", false).toList(classOf[User])) yield {
      val model: UserModel = new UserModel
      model.blocked = user.blocked
      model.name = user.name
      model.administrator = user.administrator
      model.approved = user.approved
      model.email = user.email
      model.emailConfirmed = user.emailConfirmed
      model.signature = user.signature
      model
    }
  }

  def createRecord: UserModel = {
    DependencyResolver.resolve(classOf[UserModel])
  }

  def addRecord(record: UserModel) {
    val domainModel: DomainModel = domainModelProvider.createWithTransaction
    try {

      val change: (String, String) = userSecurity.changePassword(record.password)

      val user: User = new User(
        email = record.email,
        name = record.name,
        registered = OffsetDateTime.now,
        blocked = false,
        emailConfirmed = true,
        approved = true,
        lastLogin = OffsetDateTime.now,
        lastActivity = OffsetDateTime.now,
        lastPasswordChanged = OffsetDateTime.now,
        administrator = record.administrator,
        signature = record.signature,
        passwordChangeToken = None,
        password = change._2,
        salt = change._1,
        passwordAutoGenerated = false
      )
      domainModel.create(user)
      changeTracker.addChange(classOf[User], user, EntityChangeType.ADDED, domainModel)
      domainModel.completeTransaction()
      record.password = null
      record.id = user.id
    } finally {
      if (domainModel != null) domainModel.close()
    }
  }

  def updateRecord(record: UserModel) {
    val domainModel: DomainModel = domainModelProvider.createWithTransaction
    try {
      val user: User = domainModel.query.from(classOf[User]).find(classOf[User], record.id).get
      user.name = record.name
      user.email = record.email
      user.administrator = record.administrator
      user.signature = record.signature
      if (!StringHelper.isNullOrEmpty(record.password)) {
        val change: (String, String) = userSecurity.changePassword(record.password)
        user.password = change._2
        user.salt = change._1
        user.passwordChangeToken = None
        user.passwordChangeTokenExpires = None
        user.passwordAutoGenerated = false
        user.lastPasswordChanged = OffsetDateTime.now
        changeTracker.addChange(classOf[User], user, EntityChangeType.UPDATED, domainModel)
        domainModel.update(user)
        domainModel.completeTransaction()
        record.password = null
      }
    } finally {
      if (domainModel != null) domainModel.close()
    }
  }

  def deleteRecords(recordIds: Seq[Long]): Boolean = {
    val domainModel: DomainModel = domainModelProvider.createWithTransaction
    try {
      for (userId <- recordIds) {
        domainModel.delete(classOf[User], userId)
        changeTracker.addChange(classOf[User], userId, EntityChangeType.REMOVED, domainModel)
      }
      domainModel.completeTransaction()
    } finally {
      if (domainModel != null) domainModel.close()
    }
    true
  }
}

class UserModel extends RecordModel[UserModel](TextIds.USER, classOf[UserModelCollection], classOf[User]) {

  @RecordColumn(textId = TextIds.USER_NAME)
  @InputField(textId = TextIds.USER_NAME, fieldType = InputFieldType.TEXT, required = true)
  var name: String = null
  @RecordColumn(textId = TextIds.USER_EMAIL)
  @InputField(textId = TextIds.USER_EMAIL, fieldType = com.lessmarkup.interfaces.annotations.InputFieldType.EMAIL, required = true)
  var email: String = null
  @InputField(textId = TextIds.PASSWORD, fieldType = com.lessmarkup.interfaces.annotations.InputFieldType.PASSWORD_REPEAT, required = true)
  var password: String = null
  @RecordColumn(textId = TextIds.IS_ADMINISTRATOR)
  @InputField(textId = TextIds.IS_ADMINISTRATOR, fieldType = com.lessmarkup.interfaces.annotations.InputFieldType.CHECK_BOX, defaultValue = "false")
  var administrator: Boolean = false
  var validated: Boolean = false
  var approved: Boolean = false
  var emailConfirmed: Boolean = false
  var blocked: Boolean = false
  @InputField(textId = TextIds.SIGNATURE, fieldType = com.lessmarkup.interfaces.annotations.InputFieldType.RICH_TEXT)
  var signature: Option[String] = null
}